# chatserver-muduo
基于muduo库的聊天服务器
主要技术：使用muduo库，线程池，连接池，Nginx的TCP负载均衡，redis中间件，json三方库的使用以及构建cmake自动化编译环境
为了使项目最大化解耦，将项目分层开发：网络层，业务层和数据操作层。主要实现用户注册，用户登录，添加朋友，个人聊天，群聊天，离线消息接收等，其中设置服务器的最大连接数以及群组人员的最大数。在连接池中，初始化一定数量的mysql连接对象，外部从连接池中拿走mysql连接对象，以共享指针的形式返回，方便mysql连接对象使用完，归还到连接池中，当连接池为0且不超过最大的连接数时，就往连接池中增加对象；当连接池中数量大于初始化数量，超过一定时间就会将其释放，以上两个操作都是在单独的线程中完成的。另外Nginx的TCP负载均衡较好的降低单个服务器的压力，基于分布-订阅的redis中间件消息队列是为了降低各个服务器的耦合。
利用时间轮盘将超时的客户端剔除，格子里放的不是连接，而是一个特制的Entry struct，每个Entry包含TcpConnection 的weak_ptr。Entry 的析构函数会判断连接是否还存在（用weak_ptr），如果还存在则断开连接。为了简单起见，我们不会真的把一个连接从一个格子移到另一个格子，而是采用引用计数办法，用shared_ptr 来管理Entry。如果从连接收到数据，就把对应的EntryPtr 放到这个格子里，这样它的引用计数就递增了。当Entry 的引用计数递减到零，说明它没有在任何一个格子里出现，那么连接超时，Entry 的析构函数会断开连接。其中EchoServer::onTimer() 的实现只有一行：往队尾添加一个空的Bucket，这样circular_buffer 会自动弹出队首的Bucket，并析构之。在析构Bucket 的时候，会依次析构其中的EntryPtr 对象，这样Entry 的引用计数就不用我们去操心，C++ 的值语意会帮我们搞定一切。在连接建立时，创建一个Entry 对象，把它放到timing wheel 的队尾。另外，我们还需要把Entry 的弱引用保存到TcpConnection 的context 里，因为在收到数据的时候还要用到Entry。在收到消息时，从TcpConnection 的context 中取出Entry 的弱引用，把它提升为强引用EntryPtr，然后放到当前的timing wheel 队尾
